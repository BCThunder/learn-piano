<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Scale Builder - Learn Music Theory</title>
  <link rel="stylesheet" href="styles.css">
</head>

<body>
  <div id="root"></div>

  <!-- React, ReactDOM, and Babel -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- React Components -->
  <script type="text/babel">
    const { useState, useEffect, useCallback } = React;

    // ============= Utils =============
    const NOTE_NAMES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    const WHITE_KEY_MAP = ['a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', ';', "'"];
    const BLACK_KEY_MAP = ['w', 'e', '', 't', 'y', 'u', '', 'i', 'o', 'p', ''];
    const SCALE_PATTERNS = {
      major: [2, 2, 1, 2, 2, 2, 1],
      minor: [2, 1, 2, 2, 1, 2, 2]
    };

    const generateNotes = () => {
      const notes = [];
      for (let octave = 0; octave < 2; octave++) {
        for (let i = 0; i < 12; i++) {
          notes.push({
            name: NOTE_NAMES[i],
            index: octave * 12 + i,
            isBlack: NOTE_NAMES[i].includes('#'),
            octave: octave + 4
          });
        }
      }
      return notes;
    };

    const getFrequency = (noteIndex) => {
      return 440 * Math.pow(2, (noteIndex - 9) / 12);
    };

    const buildScale = (rootIndex, pattern) => {
      const scale = [rootIndex];
      let currentIndex = rootIndex;

      for (const interval of pattern) {
        currentIndex += interval;
        scale.push(currentIndex);
      }

      return scale;
    };

    const getKeyboardLabel = (note, notes) => {
      if (note.isBlack) {
        const blackNotes = notes.filter(n => n.isBlack);
        const blackIndex = blackNotes.findIndex(n => n.index === note.index);
        const adjustedIndex = blackIndex < 5 ? blackIndex : blackIndex + 1;
        return BLACK_KEY_MAP[adjustedIndex]?.toUpperCase() || '';
      } else {
        const whiteNotes = notes.filter(n => !n.isBlack);
        const whiteIndex = whiteNotes.findIndex(n => n.index === note.index);
        return WHITE_KEY_MAP[whiteIndex]?.toUpperCase() || '';
      }
    };

    const playNote = (noteIndex, audioContext, setActiveNote) => {
      if (!audioContext) return;

      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();

      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);

      oscillator.frequency.value = getFrequency(noteIndex);
      oscillator.type = 'sine';

      gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);

      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 0.5);

      setActiveNote(noteIndex);
      setTimeout(() => setActiveNote(null), 200);
    };

    // ============= Components =============

    // Header Component
    const Header = () => {
      return (
        <div className="card header">
          <h1>Scale Builder</h1>
          <p>Learn music scales through interactive building</p>
        </div>
      );
    };

    // PianoKey Component
    const PianoKey = ({
      note,
      isHighlighted,
      isUserSelected,
      isRoot,
      isActive,
      onClick,
      keyboardLabel
    }) => {
      if (note.isBlack) {
        const whiteKeyWidth = 60;
        const blackKeyWidth = 36;

        // Determine which white key this black key belongs to (positioned at its right edge)
        // C# belongs to C, D# to D, F# to F, G# to G, A# to A
        const noteInOctave = note.index % 12;
        const octaveOffset = Math.floor(note.index / 12) * 7;

        let whiteKeyIndex; // The white key this black key belongs to
        switch (noteInOctave) {
          case 1: whiteKeyIndex = 0; break; // C# belongs to C
          case 3: whiteKeyIndex = 1; break; // D# belongs to D
          case 6: whiteKeyIndex = 3; break; // F# belongs to F
          case 8: whiteKeyIndex = 4; break; // G# belongs to G
          case 10: whiteKeyIndex = 5; break; // A# belongs to A
          default: whiteKeyIndex = 0;
        }

        const totalWhiteKeyIndex = octaveOffset + whiteKeyIndex;
        // Position black key so its center is at the right border of its white key
        const leftPosition = (totalWhiteKeyIndex * whiteKeyWidth) + whiteKeyWidth - (blackKeyWidth / 2);

        // Determine state class
        let stateClass = 'default';
        if (isActive) stateClass = 'active';
        else if (isUserSelected) stateClass = 'selected';
        else if (isHighlighted) stateClass = 'highlighted';
        else if (isRoot) stateClass = 'root';

        return (
          <div
            onClick={onClick}
            className={`piano-key black ${stateClass}`}
            style={{ left: `${leftPosition}px` }}
          >
            <div className="key-note-name black">
              {note.name}
            </div>
            <div className="key-keyboard-label black">
              {keyboardLabel}
            </div>
          </div>
        );
      } else {
        // White key
        let stateClass = 'default';
        if (isActive) stateClass = 'active';
        else if (isUserSelected) stateClass = 'selected';
        else if (isHighlighted) stateClass = 'highlighted';
        else if (isRoot) stateClass = 'root';

        const isColored = isUserSelected || isHighlighted || isRoot;

        return (
          <div
            onClick={onClick}
            className={`piano-key white ${stateClass}`}
          >
            <div className={`key-note-name white ${isColored ? 'colored' : ''}`}>
              {note.name}
            </div>
            <div className={`key-keyboard-label white ${isColored ? 'colored' : ''}`}>
              {keyboardLabel}
            </div>
          </div>
        );
      }
    };

    // Piano Component
    const Piano = ({
      notes,
      highlightedNotes,
      userNotes,
      selectedRoot,
      activeNote,
      onNoteClick,
      getKeyboardLabelFunc,
      showLegend = true
    }) => {
      return (
        <div className="card piano-container">
          <div className="piano-wrapper">
            <div className="piano-keys-container">
              {notes.filter(n => !n.isBlack).map((note) => (
                <PianoKey
                  key={note.index}
                  note={note}
                  isHighlighted={highlightedNotes.includes(note.index)}
                  isUserSelected={userNotes.includes(note.index)}
                  isRoot={note.index === selectedRoot}
                  isActive={note.index === activeNote}
                  onClick={() => onNoteClick(note.index)}
                  keyboardLabel={getKeyboardLabelFunc(note)}
                />
              ))}

              {notes.filter(n => n.isBlack).map((note) => (
                <PianoKey
                  key={note.index}
                  note={note}
                  isHighlighted={highlightedNotes.includes(note.index)}
                  isUserSelected={userNotes.includes(note.index)}
                  isRoot={note.index === selectedRoot}
                  isActive={note.index === activeNote}
                  onClick={() => onNoteClick(note.index)}
                  keyboardLabel={getKeyboardLabelFunc(note)}
                />
              ))}
            </div>
          </div>

          {showLegend && (
            <div className="legend">
              {selectedRoot !== null && (
                <div className="legend-item">
                  <div className="legend-color root"></div>
                  Root Note
                </div>
              )}
              {highlightedNotes.length > 0 && (
                <div className="legend-item">
                  <div className="legend-color scale"></div>
                  Scale Notes
                </div>
              )}
              {userNotes.length > 0 && (
                <div className="legend-item">
                  <div className="legend-color selected"></div>
                  Your Selection
                </div>
              )}
            </div>
          )}
        </div>
      );
    };

    // Tutorial Component
    const Tutorial = ({
      tutorialStep,
      selectedRoot,
      selectedScale,
      userNotes,
      notes,
      onShowMajorPattern,
      onShowMinorPattern,
      onStartPractice,
      onResetTutorial,
      scalePatterns
    }) => {
      const renderStep = () => {
        switch (tutorialStep) {
          case 0:
            return (
              <div>
                <h2>Step 1: Choose Your Root Note</h2>
                <p>
                  Every scale starts with a <strong>root note</strong>. This is the note that gives the scale its name.
                  Click any key on the piano below or press a key on your keyboard to choose your root note.
                </p>
                <p className="tip">
                  ðŸ’¡ Tip: Try starting with C (the 'A' key) - it's the easiest!
                </p>
              </div>
            );

          case 1:
            return (
              <div>
                <h2>Root Note Selected: {notes.find(n => n.index === selectedRoot)?.name}</h2>
                <p>
                  Great! Now let's learn about scale patterns. Scales are built using a pattern of intervals (semitones).
                </p>
                <div className="button-group">
                  <button onClick={onShowMajorPattern} className="btn flex primary">
                    Show Major Pattern
                  </button>
                  <button onClick={onShowMinorPattern} className="btn flex secondary">
                    Show Minor Pattern
                  </button>
                </div>
              </div>
            );

          case 2:
            return (
              <div>
                <h2>Major Scale Pattern: 2-2-1-2-2-2-1</h2>
                <p>
                  The major scale uses this pattern of semitones: <strong>2-2-1-2-2-2-1</strong>
                </p>
                <p>
                  Starting from your root note ({notes.find(n => n.index === selectedRoot)?.name}),
                  move up 2 semitones, then 2, then 1, then 2, then 2, then 2, then 1 to complete the scale.
                </p>
                <p className="tip">
                  The highlighted keys below show the complete {notes.find(n => n.index === selectedRoot)?.name} major scale.
                </p>
                <div className="button-group">
                  <button onClick={onShowMinorPattern} className="btn flex secondary">
                    Show Minor Pattern
                  </button>
                  <button onClick={onStartPractice} className="btn flex success">
                    Practice Building
                  </button>
                </div>
              </div>
            );

          case 3:
            return (
              <div>
                <h2>Minor Scale Pattern: 2-1-2-2-1-2-2</h2>
                <p>
                  The natural minor scale uses this pattern: <strong>2-1-2-2-1-2-2</strong>
                </p>
                <p>
                  Starting from your root note ({notes.find(n => n.index === selectedRoot)?.name}),
                  move up 2 semitones, then 1, then 2, then 2, then 1, then 2, then 2 to complete the scale.
                </p>
                <p className="tip">
                  The highlighted keys below show the complete {notes.find(n => n.index === selectedRoot)?.name} minor scale.
                </p>
                <div className="button-group">
                  <button onClick={onShowMajorPattern} className="btn flex primary">
                    Show Major Pattern
                  </button>
                  <button onClick={onStartPractice} className="btn flex success">
                    Practice Building
                  </button>
                </div>
              </div>
            );

          case 4:
            return (
              <div>
                <h2>Now You Try!</h2>
                <p>
                  Build a {notes.find(n => n.index === selectedRoot)?.name} {selectedScale} scale using the pattern: <strong>{scalePatterns[selectedScale].join('-')}</strong>
                </p>
                <p className="progress">
                  Progress: {userNotes.length}/8 notes selected
                </p>
                <div className="progress-display">
                  <div className="label">
                    Your scale so far:
                  </div>
                  <div className="scale-notes">
                    {userNotes.length === 0
                      ? 'Click the root note to start...'
                      : userNotes.map(i => notes.find(n => n.index === i)?.name).join(' â†’ ')}
                  </div>
                </div>
                <button onClick={onResetTutorial} className="btn full-width neutral">
                  Start Over
                </button>
              </div>
            );

          default:
            return null;
        }
      };

      return (
        <div className="card tutorial">
          {renderStep()}
        </div>
      );
    };

    // Main ScaleBuilder Component
    const ScaleBuilder = () => {
      const [tutorialStep, setTutorialStep] = useState(0);
      const [selectedRoot, setSelectedRoot] = useState(null);
      const [selectedScale, setSelectedScale] = useState(null);
      const [userNotes, setUserNotes] = useState([]);
      const [highlightedNotes, setHighlightedNotes] = useState([]);
      const [activeNote, setActiveNote] = useState(null);
      const [audioContext, setAudioContext] = useState(null);

      const notes = generateNotes();

      useEffect(() => {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        setAudioContext(ctx);
        return () => ctx.close();
      }, []);

      const handleNoteClick = useCallback((noteIndex) => {
        playNote(noteIndex, audioContext, setActiveNote);

        if (tutorialStep === 0) {
          setSelectedRoot(noteIndex);
          setTutorialStep(1);
        } else if (tutorialStep === 4) {
          if (userNotes.length === 0) {
            if (noteIndex === selectedRoot) {
              setUserNotes([noteIndex]);
            }
          } else if (!userNotes.includes(noteIndex)) {
            const newUserNotes = [...userNotes, noteIndex];
            setUserNotes(newUserNotes);

            const correctScale = buildScale(selectedRoot, SCALE_PATTERNS[selectedScale]);
            if (newUserNotes.length === correctScale.length) {
              const isCorrect = newUserNotes.every((note, i) => note === correctScale[i]);
              setTimeout(() => {
                if (isCorrect) {
                  alert('Perfect! You built the scale correctly! ðŸŽ‰');
                } else {
                  alert('Not quite right. Try again!');
                }
                setUserNotes([]);
              }, 300);
            }
          }
        }
      }, [tutorialStep, selectedRoot, userNotes, selectedScale, audioContext]);

      useEffect(() => {
        const handleKeyDown = (e) => {
          const key = e.key.toLowerCase();

          const whiteKeyIndex = WHITE_KEY_MAP.indexOf(key);
          if (whiteKeyIndex !== -1) {
            const whiteNotes = notes.filter(n => !n.isBlack);
            if (whiteKeyIndex < whiteNotes.length) {
              const note = whiteNotes[whiteKeyIndex];
              handleNoteClick(note.index);
            }
            return;
          }

          const blackKeyIndex = BLACK_KEY_MAP.indexOf(key);
          if (blackKeyIndex !== -1 && BLACK_KEY_MAP[blackKeyIndex] !== '') {
            const blackNotes = notes.filter(n => n.isBlack);
            const adjustedIndex = blackKeyIndex - (blackKeyIndex > 4 ? 1 : 0);
            if (adjustedIndex < blackNotes.length) {
              const note = blackNotes[adjustedIndex];
              handleNoteClick(note.index);
            }
          }
        };

        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, [notes, handleNoteClick]);

      const showMajorPattern = () => {
        setSelectedScale('major');
        const scale = buildScale(selectedRoot, SCALE_PATTERNS.major);
        setHighlightedNotes(scale);
        setTutorialStep(2);
      };

      const showMinorPattern = () => {
        setSelectedScale('minor');
        const scale = buildScale(selectedRoot, SCALE_PATTERNS.minor);
        setHighlightedNotes(scale);
        setTutorialStep(3);
      };

      const startPractice = () => {
        setHighlightedNotes([]);
        setUserNotes([]);
        setTutorialStep(4);
      };

      const resetTutorial = () => {
        setTutorialStep(0);
        setSelectedRoot(null);
        setSelectedScale(null);
        setUserNotes([]);
        setHighlightedNotes([]);
      };

      return (
        <div className="app-container">
          <Header />

          <Tutorial
            tutorialStep={tutorialStep}
            selectedRoot={selectedRoot}
            selectedScale={selectedScale}
            userNotes={userNotes}
            notes={notes}
            onShowMajorPattern={showMajorPattern}
            onShowMinorPattern={showMinorPattern}
            onStartPractice={startPractice}
            onResetTutorial={resetTutorial}
            scalePatterns={SCALE_PATTERNS}
          />

          <Piano
            notes={notes}
            highlightedNotes={tutorialStep === 4 ? [] : highlightedNotes}
            userNotes={userNotes}
            selectedRoot={selectedRoot}
            activeNote={activeNote}
            onNoteClick={handleNoteClick}
            getKeyboardLabelFunc={(note) => getKeyboardLabel(note, notes)}
          />
        </div>
      );
    };

    // Render the app
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<ScaleBuilder />);
  </script>
</body>

</html>